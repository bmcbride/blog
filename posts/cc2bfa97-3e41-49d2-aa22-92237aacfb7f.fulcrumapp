{
  "form": {
    "id": "cc2bfa97-3e41-49d2-aa22-92237aacfb7f",
    "name": "Event Verification (Arabic)",
    "description": "1.0.0",
    "bounding_box": null,
    "record_title_key": "f3f6",
    "title_field_keys": [
      "f3f6"
    ],
    "status_field": {
      "type": "StatusField",
      "label": "Status",
      "key": "@status",
      "data_name": "status",
      "default_value": "Submitted",
      "enabled": true,
      "read_only": false,
      "hidden": false,
      "description": "",
      "choices": [
        {
          "label": "Submitted",
          "value": "Submitted",
          "color": "#CB0D0C"
        },
        {
          "label": "Rejected",
          "value": "Rejected",
          "color": "#FFD300"
        },
        {
          "label": "Approved",
          "value": "Approved",
          "color": "#87D30F"
        },
        {
          "label": "Paid",
          "value": "Paid",
          "color": "#1891C9"
        }
      ],
      "required": false,
      "disabled": false,
      "default_previous_value": false
    },
    "auto_assign": true,
    "hidden_on_dashboard": false,
    "record_count": 1,
    "geometry_types": [
      "Point"
    ],
    "geometry_required": true,
    "script": "var storage = STORAGE();\nvar noGeotags = [];\n\nfunction checkPhoto(event) {\n  if (!event.value.latitude || !event.value.latitude || event.value.latitude === 0 || event.value.latitude === 0) {\n    noGeotags.push(event.value.id);\n    storage.setItem('noGeotags', noGeotags);\n    ALERT('This photo is NOT geotagged. Please remove this photo, enable photo geotagging on your device and try again.');\n  }\n}\n\nfunction removePhoto(event) {\n  var index = noGeotags.indexOf(event.value.id);\n  noGeotags.splice(index, 1);\n  storage.setItem('noGeotags', noGeotags);\n}\n\nfunction validateRecord(event) {\n  var notags = JSON.parse(JSON.stringify('noGeotags'));\n  if (notags.length > 0) {\n    ALERT(INSPECT(notags));\n    var photos = $photos;\n    for (var i = 0; i < photos.length; i++) {\n      for (var ii = 0; ii < notags.length; ii++) {\n        if (photos[i].photo_id == notags[ii]) {\n          var index = i+1;\n          INVALID('Photo #' + index + ' is not geotagged. Please remove this photo.');\n        }\n      }\n    }\n  }\n}\n\nON('add-photo', 'photos', checkPhoto);\nON('remove-photo', 'photos', removePhoto);\nON('validate-record', validateRecord);\n\n\nON('load-record', function(event) {\n  var adminRoles = ['Owner'];\n\n  // enable the fields if the current role is one of the designated admin roles...\n  if (adminRoles.indexOf(ROLE()) !== -1) {\n    // make some fields editable by turning off the read-only flag\n    SETREADONLY('@status', false); // @status is the special data name for the status field\n  }\n});",
    "elements": [
      {
        "type": "YesNoField",
        "key": "f3f6",
        "label": "delivered",
        "description": null,
        "required": false,
        "disabled": false,
        "hidden": true,
        "data_name": "delivered",
        "default_value": "yes",
        "visible_conditions_type": null,
        "visible_conditions": null,
        "required_conditions_type": null,
        "required_conditions": null,
        "positive": {
          "label": "Yes",
          "value": "yes"
        },
        "negative": {
          "label": "No",
          "value": "no"
        },
        "neutral": {
          "label": "N/A",
          "value": "n/a"
        },
        "neutral_enabled": false,
        "default_previous_value": false
      },
      {
        "type": "CalculatedField",
        "key": "a27f",
        "label": "App Version",
        "description": null,
        "required": false,
        "disabled": false,
        "hidden": true,
        "data_name": "app_version",
        "default_value": null,
        "visible_conditions_type": null,
        "visible_conditions": null,
        "required_conditions_type": null,
        "required_conditions": [],
        "expression": "this.form.description",
        "display": {
          "style": "text",
          "currency": null
        },
        "default_values": null,
        "default_previous_value": false
      },
      {
        "type": "Section",
        "key": "1f05",
        "label": "??????? ????",
        "description": null,
        "required": false,
        "disabled": false,
        "hidden": false,
        "data_name": "general_information",
        "default_value": null,
        "visible_conditions_type": null,
        "visible_conditions": null,
        "required_conditions_type": null,
        "required_conditions": null,
        "display": "inline",
        "elements": [
          {
            "type": "PhotoField",
            "key": "dfc4",
            "label": "?????",
            "description": "??? ?? ?????? ??????? ?????",
            "required": true,
            "disabled": false,
            "hidden": false,
            "data_name": "photos",
            "default_value": null,
            "visible_conditions_type": null,
            "visible_conditions": null,
            "required_conditions_type": null,
            "required_conditions": null,
            "min_length": null,
            "max_length": null
          },
          {
            "type": "TextField",
            "key": "d148",
            "label": "Street Name",
            "description": "Name of the street this checkpoint or roadblock is located on?",
            "required": false,
            "disabled": false,
            "hidden": true,
            "data_name": "street_name_en",
            "default_value": null,
            "visible_conditions_type": null,
            "visible_conditions": null,
            "required_conditions_type": null,
            "required_conditions": null,
            "numeric": false,
            "pattern": null,
            "pattern_description": null,
            "min_length": null,
            "max_length": null,
            "default_previous_value": false
          },
          {
            "type": "TextField",
            "key": "f470",
            "label": "??? ??????",
            "description": "??? ?????? ???? ??? ??? ???? ??????? ?? ???????",
            "required": false,
            "disabled": false,
            "hidden": false,
            "data_name": "street_name_native",
            "default_value": null,
            "visible_conditions_type": null,
            "visible_conditions": null,
            "required_conditions_type": null,
            "required_conditions": null,
            "numeric": false,
            "pattern": null,
            "pattern_description": null,
            "min_length": null,
            "max_length": null,
            "default_previous_value": false
          },
          {
            "type": "TextField",
            "key": "37b9",
            "label": "Neighborhood Name",
            "description": "What is the name of the neighborhood where this checkpoint or roadblock is located?",
            "required": false,
            "disabled": false,
            "hidden": true,
            "data_name": "neighborhood_name_en",
            "default_value": null,
            "visible_conditions_type": null,
            "visible_conditions": null,
            "required_conditions_type": null,
            "required_conditions": null,
            "numeric": false,
            "pattern": null,
            "pattern_description": null,
            "min_length": null,
            "max_length": null,
            "default_previous_value": false
          },
          {
            "type": "TextField",
            "key": "4d75",
            "label": "??? ????",
            "description": "??? ???? ???? ??? ??? ???? ??????? ?? ???????",
            "required": false,
            "disabled": false,
            "hidden": false,
            "data_name": "neighborhood_name_native",
            "default_value": null,
            "visible_conditions_type": null,
            "visible_conditions": null,
            "required_conditions_type": null,
            "required_conditions": null,
            "numeric": false,
            "pattern": null,
            "pattern_description": null,
            "min_length": null,
            "max_length": null,
            "default_previous_value": false
          }
        ]
      },
      {
        "type": "Section",
        "key": "fb0b",
        "label": "Source Metadata",
        "description": null,
        "required": false,
        "disabled": false,
        "hidden": true,
        "data_name": "source_metadata",
        "default_value": null,
        "visible_conditions_type": null,
        "visible_conditions": null,
        "required_conditions_type": null,
        "required_conditions": null,
        "display": "inline",
        "elements": [
          {
            "type": "TextField",
            "key": "d8f2",
            "label": "Source ID",
            "description": null,
            "required": false,
            "disabled": false,
            "hidden": true,
            "data_name": "source_id",
            "default_value": null,
            "visible_conditions_type": null,
            "visible_conditions": null,
            "required_conditions_type": null,
            "required_conditions": null,
            "numeric": false,
            "pattern": null,
            "pattern_description": null,
            "min_length": null,
            "max_length": null,
            "default_previous_value": false
          },
          {
            "type": "TextField",
            "key": "d949",
            "label": "Source Version",
            "description": null,
            "required": false,
            "disabled": false,
            "hidden": true,
            "data_name": "source_version",
            "default_value": null,
            "visible_conditions_type": null,
            "visible_conditions": null,
            "required_conditions_type": null,
            "required_conditions": null,
            "numeric": false,
            "pattern": null,
            "pattern_description": null,
            "min_length": null,
            "max_length": null,
            "default_previous_value": false
          },
          {
            "type": "TextField",
            "key": "ebe5",
            "label": "Source Language",
            "description": null,
            "required": false,
            "disabled": false,
            "hidden": true,
            "data_name": "source_language",
            "default_value": "Arabic",
            "visible_conditions_type": null,
            "visible_conditions": null,
            "required_conditions_type": null,
            "required_conditions": null,
            "numeric": false,
            "pattern": null,
            "pattern_description": null,
            "min_length": null,
            "max_length": null,
            "default_previous_value": false
          },
          {
            "type": "TextField",
            "key": "48a7",
            "label": "Source Project",
            "description": null,
            "required": false,
            "disabled": false,
            "hidden": true,
            "data_name": "source_project",
            "default_value": null,
            "visible_conditions_type": null,
            "visible_conditions": null,
            "required_conditions_type": null,
            "required_conditions": null,
            "numeric": false,
            "pattern": null,
            "pattern_description": null,
            "min_length": null,
            "max_length": null,
            "default_previous_value": false
          },
          {
            "type": "TextField",
            "key": "966d",
            "label": "Source Account",
            "description": null,
            "required": false,
            "disabled": false,
            "hidden": true,
            "data_name": "source_account",
            "default_value": null,
            "visible_conditions_type": null,
            "visible_conditions": null,
            "required_conditions_type": null,
            "required_conditions": null,
            "numeric": false,
            "pattern": null,
            "pattern_description": null,
            "min_length": null,
            "max_length": null,
            "default_previous_value": false
          },
          {
            "type": "TextField",
            "key": "d73a",
            "label": "Source Created",
            "description": null,
            "required": false,
            "disabled": false,
            "hidden": true,
            "data_name": "source_created_at",
            "default_value": null,
            "visible_conditions_type": null,
            "visible_conditions": null,
            "required_conditions_type": null,
            "required_conditions": null,
            "numeric": false,
            "pattern": null,
            "pattern_description": null,
            "min_length": null,
            "max_length": null,
            "default_previous_value": false
          },
          {
            "type": "TextField",
            "key": "e202",
            "label": "Source Updated",
            "description": null,
            "required": false,
            "disabled": false,
            "hidden": true,
            "data_name": "source_updated_at",
            "default_value": null,
            "visible_conditions_type": null,
            "visible_conditions": null,
            "required_conditions_type": null,
            "required_conditions": null,
            "numeric": false,
            "pattern": null,
            "pattern_description": null,
            "min_length": null,
            "max_length": null,
            "default_previous_value": false
          },
          {
            "type": "TextField",
            "key": "27a7",
            "label": "Country",
            "description": null,
            "required": false,
            "disabled": false,
            "hidden": true,
            "data_name": "country",
            "default_value": "Syria",
            "visible_conditions_type": null,
            "visible_conditions": null,
            "required_conditions_type": null,
            "required_conditions": null,
            "numeric": false,
            "pattern": null,
            "pattern_description": null,
            "min_length": null,
            "max_length": null,
            "default_previous_value": false
          },
          {
            "type": "CalculatedField",
            "key": "8fb3",
            "label": "MGRS",
            "description": null,
            "required": false,
            "disabled": false,
            "hidden": true,
            "data_name": "mgrs",
            "default_value": null,
            "visible_conditions_type": null,
            "visible_conditions": null,
            "required_conditions_type": null,
            "required_conditions": [],
            "expression": "function Vector3d(x, y, z) {\n    // allow instantiation without 'new'\n    if (!(this instanceof Vector3d)) return new Vector3d(x, y, z);\n\n    this.x = Number(x);\n    this.y = Number(y);\n    this.z = Number(z);\n}\n\n\n/**\n * Adds supplied vector to ?this? vector.\n *\n * @param   {Vector3d} v - Vector to be added to this vector.\n * @returns {Vector3d} Vector representing sum of this and v.\n */\nVector3d.prototype.plus = function(v) {\n    if (!(v instanceof Vector3d)) throw new TypeError('v is not Vector3d object');\n\n    return new Vector3d(this.x + v.x, this.y + v.y, this.z + v.z);\n};\n\n\n/**\n * Subtracts supplied vector from ?this? vector.\n *\n * @param   {Vector3d} v - Vector to be subtracted from this vector.\n * @returns {Vector3d} Vector representing difference between this and v.\n */\nVector3d.prototype.minus = function(v) {\n    if (!(v instanceof Vector3d)) throw new TypeError('v is not Vector3d object');\n\n    return new Vector3d(this.x - v.x, this.y - v.y, this.z - v.z);\n};\n\n\n/**\n * Multiplies ?this? vector by a scalar value.\n *\n * @param   {number}   x - Factor to multiply this vector by.\n * @returns {Vector3d} Vector scaled by x.\n */\nVector3d.prototype.times = function(x) {\n    x = Number(x);\n\n    return new Vector3d(this.x * x, this.y * x, this.z * x);\n};\n\n\n/**\n * Divides ?this? vector by a scalar value.\n *\n * @param   {number}   x - Factor to divide this vector by.\n * @returns {Vector3d} Vector divided by x.\n */\nVector3d.prototype.dividedBy = function(x) {\n    x = Number(x);\n\n    return new Vector3d(this.x / x, this.y / x, this.z / x);\n};\n\n\n/**\n * Multiplies ?this? vector by the supplied vector using dot (scalar) product.\n *\n * @param   {Vector3d} v - Vector to be dotted with this vector.\n * @returns {number} Dot product of ?this? and v.\n */\nVector3d.prototype.dot = function(v) {\n    if (!(v instanceof Vector3d)) throw new TypeError('v is not Vector3d object');\n\n    return this.x*v.x + this.y*v.y + this.z*v.z;\n};\n\n\n/**\n * Multiplies ?this? vector by the supplied vector using cross (vector) product.\n *\n * @param   {Vector3d} v - Vector to be crossed with this vector.\n * @returns {Vector3d} Cross product of ?this? and v.\n */\nVector3d.prototype.cross = function(v) {\n    if (!(v instanceof Vector3d)) throw new TypeError('v is not Vector3d object');\n\n    var x = this.y*v.z - this.z*v.y;\n    var y = this.z*v.x - this.x*v.z;\n    var z = this.x*v.y - this.y*v.x;\n\n    return new Vector3d(x, y, z);\n};\n\n\n/**\n * Negates a vector to point in the opposite direction\n *\n * @returns {Vector3d} Negated vector.\n */\nVector3d.prototype.negate = function() {\n    return new Vector3d(-this.x, -this.y, -this.z);\n};\n\n\n/**\n * Length (magnitude or norm) of ?this? vector\n *\n * @returns {number} Magnitude of this vector.\n */\nVector3d.prototype.length = function() {\n    return Math.sqrt(this.x*this.x + this.y*this.y + this.z*this.z);\n};\n\n\n/**\n * Normalizes a vector to its unit vector\n * ? if the vector is already unit or is zero magnitude, this is a no-op.\n *\n * @returns {Vector3d} Normalised version of this vector.\n */\nVector3d.prototype.unit = function() {\n    var norm = this.length();\n    if (norm == 1) return this;\n    if (norm == 0) return this;\n\n    var x = this.x/norm;\n    var y = this.y/norm;\n    var z = this.z/norm;\n\n    return new Vector3d(x, y, z);\n};\n\n\n/**\n * Calculates the angle between ?this? vector and supplied vector.\n *\n * @param   {Vector3d} v\n * @param   {Vector3d} [vSign] - If supplied (and out of plane of this and v), angle is signed +ve if\n *     this->v is clockwise looking along vSign, -ve in opposite direction (otherwise unsigned angle).\n * @returns {number} Angle (in radians) between this vector and supplied vector.\n */\nVector3d.prototype.angleTo = function(v, vSign) {\n    if (!(v instanceof Vector3d)) throw new TypeError('v is not Vector3d object');\n\n    var sin? = this.cross(v).length();\n    var cos? = this.dot(v);\n\n    if (vSign !== undefined) {\n        if (!(vSign instanceof Vector3d)) throw new TypeError('vSign is not Vector3d object');\n        // use vSign as reference to get sign of sin?\n        sin? = this.cross(v).dot(vSign)<0 ? -sin? : sin?;\n    }\n\n    return Math.atan2(sin?, cos?);\n};\n\n\n/**\n * Rotates ?this? point around an axis by a specified angle.\n *\n * @param   {Vector3d} axis - The axis being rotated around.\n * @param   {number}   theta - The angle of rotation (in radians).\n * @returns {Vector3d} The rotated point.\n */\nVector3d.prototype.rotateAround = function(axis, theta) {\n    if (!(axis instanceof Vector3d)) throw new TypeError('axis is not Vector3d object');\n\n    // en.wikipedia.org/wiki/Rotation_matrix#Rotation_matrix_from_axis_and_angle\n    // en.wikipedia.org/wiki/Quaternions_and_spatial_rotation#Quaternion-derived_rotation_matrix\n    var p1 = this.unit();\n    var p = [ p1.x, p1.y, p1.z ]; // the point being rotated\n    var a = axis.unit();          // the axis being rotated around\n    var s = Math.sin(theta);\n    var c = Math.cos(theta);\n    // quaternion-derived rotation matrix\n    var q = [\n        [ a.x*a.x*(1-c) + c,     a.x*a.y*(1-c) - a.z*s, a.x*a.z*(1-c) + a.y*s],\n        [ a.y*a.x*(1-c) + a.z*s, a.y*a.y*(1-c) + c,     a.y*a.z*(1-c) - a.x*s],\n        [ a.z*a.x*(1-c) - a.y*s, a.z*a.y*(1-c) + a.x*s, a.z*a.z*(1-c) + c    ]\n    ];\n    // multiply q ? p\n    var qp = [0, 0, 0];\n    for (var i=0; i<3; i++) {\n        for (var j=0; j<3; j++) {\n            qp[i] += q[i][j] * p[j];\n        }\n    }\n    var p2 = new Vector3d(qp[0], qp[1], qp[2]);\n    return p2;\n    // qv en.wikipedia.org/wiki/Rodrigues'_rotation_formula...\n};\n\n\n/**\n * String representation of vector.\n *\n * @param   {number} [precision=3] - Number of decimal places to be used.\n * @returns {string} Vector represented as [x,y,z].\n */\nVector3d.prototype.toString = function(precision) {\n    var p = (precision === undefined) ? 3 : Number(precision);\n\n    var str = '[' + this.x.toFixed(p) + ',' + this.y.toFixed(p) + ',' + this.z.toFixed(p) + ']';\n\n    return str;\n};\n\nfunction LatLon(lat, lon, datum) {\n    // allow instantiation without 'new'\n    if (!(this instanceof LatLon)) return new LatLon(lat, lon, datum);\n\n    if (datum === undefined) datum = LatLon.datum.WGS84;\n\n    this.lat = Number(lat);\n    this.lon = Number(lon);\n    this.datum = datum;\n}\n\n\n/**\n * Ellipsoid parameters; major axis (a), minor axis (b), and flattening (f) for each ellipsoid.\n */\nLatLon.ellipsoid = {\n    WGS84:        { a: 6378137,     b: 6356752.31425, f: 1/298.257223563 },\n    GRS80:        { a: 6378137,     b: 6356752.31414, f: 1/298.257222101 },\n    Airy1830:     { a: 6377563.396, b: 6356256.909,   f: 1/299.3249646   },\n    AiryModified: { a: 6377340.189, b: 6356034.448,   f: 1/299.3249646   },\n    Intl1924:     { a: 6378388,     b: 6356911.946,   f: 1/297           },\n    Bessel1841:   { a: 6377397.155, b: 6356078.963,   f: 1/299.152815351 }\n};\n\n/**\n * Datums; with associated *ellipsoid* and Helmert *transform* parameters to convert from WGS 84\n * into given datum.\n *\n * More are available from earth-info.nga.mil/GandG/coordsys/datums/NATO_DT.pdf,\n * www.fieldenmaps.info/cconv/web/cconv_params.js\n */\nLatLon.datum = {\n    WGS84: {\n        ellipsoid: LatLon.ellipsoid.WGS84,\n        transform: { tx:    0.0,    ty:    0.0,     tz:    0.0,    // m\n                     rx:    0.0,    ry:    0.0,     rz:    0.0,    // sec\n                      s:    0.0 }                                  // ppm\n    },\n    NAD83: { // (2009); functionally ? WGS84 - www.uvm.edu/giv/resources/WGS84_NAD83.pdf\n        ellipsoid: LatLon.ellipsoid.GRS80,\n        transform: { tx:    1.004,  ty:   -1.910,   tz:   -0.515,  // m\n                     rx:    0.0267, ry:    0.00034, rz:    0.011,  // sec\n                      s:   -0.0015 }                               // ppm\n    }, // note: if you *really* need to convert WGS84<->NAD83, you need more knowledge than this!\n    OSGB36: { // www.ordnancesurvey.co.uk/docs/support/guide-coordinate-systems-great-britain.pdf\n        ellipsoid: LatLon.ellipsoid.Airy1830,\n        transform: { tx: -446.448,  ty:  125.157,   tz: -542.060,  // m\n                     rx:   -0.1502, ry:   -0.2470,  rz:   -0.8421, // sec\n                      s:   20.4894 }                               // ppm\n    },\n    ED50: { // og.decc.gov.uk/en/olgs/cms/pons_and_cop/pons/pon4/pon4.aspx\n        ellipsoid: LatLon.ellipsoid.Intl1924,\n        transform: { tx:   89.5,    ty:   93.8,     tz:  123.1,    // m\n                     rx:    0.0,    ry:    0.0,     rz:    0.156,  // sec\n                      s:   -1.2 }                                  // ppm\n    },\n    Irl1975: { // osi.ie/OSI/media/OSI/Content/Publications/transformations_booklet.pdf\n        ellipsoid: LatLon.ellipsoid.AiryModified,\n        transform: { tx: -482.530,  ty:  130.596,   tz: -564.557,  // m\n                     rx:   -1.042,  ry:   -0.214,   rz:   -0.631,  // sec\n                      s:   -8.150 }                                // ppm\n    }, // note: many sources have opposite sign to rotations - to be checked!\n    TokyoJapan: { // www.geocachingtoolbox.com?page=datumEllipsoidDetails\n        ellipsoid: LatLon.ellipsoid.Bessel1841,\n        transform: { tx:  148,      ty: -507,       tz: -685,      // m\n                     rx:    0,      ry:    0,       rz:    0,      // sec\n                      s:    0 }                                    // ppm\n    }\n};\n\n\n/**\n * Converts ?this? lat/lon coordinate to new coordinate system.\n *\n * @param   {LatLon.datum} toDatum - Datum this coordinate is to be converted to.\n * @returns {LatLon} This point converted to new datum.\n *\n * @example\n *     var pWGS84 = new LatLon(51.4778, -0.0016, LatLon.datum.WGS84);\n *     var pOSGB = pWGS84.convertDatum(LatLon.datum.OSGB36); // pOSGB.toString(): 51.4773?N, 000.0000?E\n */\nLatLon.prototype.convertDatum = function(toDatum) {\n    var oldLatLon = this;\n    var transform;\n\n    if (oldLatLon.datum == LatLon.datum.WGS84) {\n        // converting from WGS 84\n        transform = toDatum.transform;\n    }\n    if (toDatum == LatLon.datum.WGS84) {\n        // converting to WGS 84; use inverse transform (don't overwrite original!)\n        transform = {};\n        for (var param in oldLatLon.datum.transform) {\n            if (oldLatLon.datum.transform.hasOwnProperty(param)) {\n                transform[param] = -oldLatLon.datum.transform[param];\n            }\n        }\n    }\n    if (transform === undefined) {\n        // neither this.datum nor toDatum are WGS84: convert this to WGS84 first\n        oldLatLon = this.convertDatum(LatLon.datum.WGS84);\n        transform = toDatum.transform;\n    }\n\n    var cartesian = oldLatLon.toCartesian();         // convert polar to cartesian...\n    cartesian = cartesian.applyTransform(transform); // ...apply transform...\n    var newLatLon = cartesian.toLatLonE(toDatum);    // ...and convert cartesian to polar\n\n    return newLatLon;\n};\n\n\n/**\n * Converts ?this? point from (geodetic) latitude/longitude coordinates to (geocentric) cartesian\n * (x/y/z) coordinates.\n *\n * @returns {Vector3d} Vector pointing to lat/lon point, with x, y, z in metres from earth centre.\n */\nLatLon.prototype.toCartesian = function() {\n    var ? = this.lat.toRadians(), ? = this.lon.toRadians();\n    var h = 0; // height above ellipsoid - not currently used\n    var a = this.datum.ellipsoid.a, b = this.datum.ellipsoid.b;\n\n    var sin? = Math.sin(?), cos? = Math.cos(?);\n    var sin? = Math.sin(?), cos? = Math.cos(?);\n\n    var eSq = (a*a - b*b) / (a*a);\n    var ? = a / Math.sqrt(1 - eSq*sin?*sin?);\n\n    var x = (?+h) * cos? * cos?;\n    var y = (?+h) * cos? * sin?;\n    var z = ((1-eSq)*? + h) * sin?;\n\n    var point = new Vector3d(x, y, z);\n\n    return point;\n};\n\n\n/**\n * Converts ?this? (geocentric) cartesian (x/y/z) point to (ellipsoidal geodetic) latitude/longitude\n * coordinates on specified datum.\n *\n * Uses Bowring?s (1985) formulation for ?m precision.\n *\n * @param {LatLon.datum.transform} datum - Datum to use when converting point.\n */\nVector3d.prototype.toLatLonE = function(datum) {\n    var x = this.x, y = this.y, z = this.z;\n    var a = datum.ellipsoid.a, b = datum.ellipsoid.b;\n\n    var e2 = (a*a-b*b) / (a*a); // 1st eccentricity squared\n    var ?2 = (a*a-b*b) / (b*b); // 2nd eccentricity squared\n    var p = Math.sqrt(x*x + y*y); // distance from minor axis\n    var R = Math.sqrt(p*p + z*z); // polar radius\n\n    // parametric latitude (Bowring eqn 17, replacing tan? = z?a / p?b)\n    var tan? = (b*z)/(a*p) * (1+?2*b/R);\n    var sin? = tan? / Math.sqrt(1+tan?*tan?);\n    var cos? = sin? / tan?;\n\n    // geodetic latitude (Bowring eqn 18)\n    var ? = Math.atan2(z + ?2*b*sin?*sin?*sin?,\n                       p - e2*a*cos?*cos?*cos?);\n\n    // longitude\n    var ? = Math.atan2(y, x);\n\n    // height above ellipsoid (Bowring eqn 7) [not currently used]\n    var sin? = Math.sin(?), cos? = Math.cos(?);\n    var ? = a*Math.sqrt(1-e2*sin?*sin?); // length of the normal terminated by the minor axis\n    var h = p*cos? + z*sin? - (a*a/?);\n\n    var point = new LatLon(?.toDegrees(), ?.toDegrees(), datum);\n\n    return point;\n};\n\n/**\n * Applies Helmert transform to ?this? point using transform parameters t.\n *\n * @private\n * @param {LatLon.datum.transform} t - Transform to apply to this point.\n */\nVector3d.prototype.applyTransform = function(t)   {\n    var x1 = this.x, y1 = this.y, z1 = this.z;\n\n    var tx = t.tx, ty = t.ty, tz = t.tz;\n    var rx = (t.rx/3600).toRadians(); // normalise seconds to radians\n    var ry = (t.ry/3600).toRadians(); // normalise seconds to radians\n    var rz = (t.rz/3600).toRadians(); // normalise seconds to radians\n    var s1 = t.s/1e6 + 1;             // normalise ppm to (s+1)\n\n    // apply transform\n    var x2 = tx + x1*s1 - y1*rz + z1*ry;\n    var y2 = ty + x1*rz + y1*s1 - z1*rx;\n    var z2 = tz - x1*ry + y1*rx + z1*s1;\n\n    var point = new Vector3d(x2, y2, z2);\n\n    return point;\n};\n\n\n/**\n * Returns a string representation of ?this? point, formatted as degrees, degrees+minutes, or\n * degrees+minutes+seconds.\n *\n * @param   {string} [format=dms] - Format point as 'd', 'dm', 'dms'.\n * @param   {number} [dp=0|2|4] - Number of decimal places to use - default 0 for dms, 2 for dm, 4 for d.\n * @returns {string} Comma-separated latitude/longitude.\n */\nLatLon.prototype.toString = function(format, dp) {\n    return Dms.toLat(this.lat, format, dp) + ', ' + Dms.toLon(this.lon, format, dp);\n};\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\n/** Extend Number object with method to convert numeric degrees to radians */\nif (Number.prototype.toRadians === undefined) {\n    Number.prototype.toRadians = function() { return this * Math.PI / 180; };\n}\n\n/** Extend Number object with method to convert radians to numeric (signed) degrees */\nif (Number.prototype.toDegrees === undefined) {\n    Number.prototype.toDegrees = function() { return this * 180 / Math.PI; };\n}\n\nfunction Utm(zone, hemisphere, easting, northing, datum, convergence, scale) {\n    if (!(this instanceof Utm)) { // allow instantiation without 'new'\n        return new Utm(zone, hemisphere, easting, northing, datum, convergence, scale);\n    }\n\n    if (datum === undefined) datum = LatLon.datum.WGS84; // default if not supplied\n    if (convergence === undefined) convergence = null;   // default if not supplied\n    if (scale === undefined) scale = null;               // default if not supplied\n\n    if (!(1<=zone && zone<=60)) throw new Error('Invalid UTM zone '+zone);\n    if (!hemisphere.match(/[NS]/i)) throw new Error('Invalid UTM hemisphere '+hemisphere);\n    // range-check easting/northing (with 40km overlap between zones) - this this worthwhile?\n    //if (!(120e3<=easting && easting<=880e3)) throw new Error('Invalid UTM easting '+ easting);\n    //if (!(0<=northing && northing<=10000e3)) throw new Error('Invalid UTM northing '+ northing);\n\n    this.zone = Number(zone);\n    this.hemisphere = hemisphere.toUpperCase();\n    this.easting = Number(easting);\n    this.northing = Number(northing);\n    this.datum = datum;\n    this.convergence = convergence===null ? null : Number(convergence);\n    this.scale = scale===null ? null : Number(scale);\n}\n\n\n/**\n * Converts latitude/longitude to UTM coordinate.\n *\n * Implements Karney?s method, using Kr?ger series to order n^6, giving results accurate to 5nm for\n * distances up to 3900km from the central meridian.\n *\n * @returns {Utm}   UTM coordinate.\n * @throws  {Error} If point not valid, if point outside latitude range.\n *\n * @example\n *   var latlong = new LatLon(48.8582, 2.2945, LatLon.datum.WGS84);\n *   var utmCoord = latlong.toUtm(); // utmCoord.toString(): '31 N 448252 5411933'\n */\nLatLon.prototype.toUtm = function() {\n    if (isNaN(this.lat) || isNaN(this.lon)) throw new Error('Invalid point');\n    if (!(-80<=this.lat && this.lat<=84)) throw new Error('Outside UTM limits');\n\n    var falseEasting = 500e3, falseNorthing = 10000e3;\n\n    var zone = Math.floor((this.lon+180)/6) + 1; // longitudinal zone\n    var ?0 = ((zone-1)*6 - 180 + 3).toRadians(); // longitude of central meridian\n\n    // ---- handle Norway/Svalbard exceptions\n    // grid zones are 8? tall; 0?N is offset 10 into latitude bands array\n    var mgrsLatBands = 'CDEFGHJKLMNPQRSTUVWXX'; // X is repeated for 80-84?N\n    var latBand = mgrsLatBands.charAt(Math.floor(this.lat/8+10));\n    // adjust zone & central meridian for Norway\n    if (zone==31 && latBand=='V' && this.lon>= 3) { zone++; ?0 += (6).toRadians(); }\n    // adjust zone & central meridian for Svalbard\n    if (zone==32 && latBand=='X' && this.lon<  9) { zone--; ?0 -= (6).toRadians(); }\n    if (zone==32 && latBand=='X' && this.lon>= 9) { zone++; ?0 += (6).toRadians(); }\n    if (zone==34 && latBand=='X' && this.lon< 21) { zone--; ?0 -= (6).toRadians(); }\n    if (zone==34 && latBand=='X' && this.lon>=21) { zone++; ?0 += (6).toRadians(); }\n    if (zone==36 && latBand=='X' && this.lon< 33) { zone--; ?0 -= (6).toRadians(); }\n    if (zone==36 && latBand=='X' && this.lon>=33) { zone++; ?0 += (6).toRadians(); }\n\n    var ? = this.lat.toRadians();      // latitude ? from equator\n    var ? = this.lon.toRadians() - ?0; // longitude ? from central meridian\n\n    var a = this.datum.ellipsoid.a, f = this.datum.ellipsoid.f;\n    // WGS 84: a = 6378137, b = 6356752.314245, f = 1/298.257223563;\n\n    var k0 = 0.9996; // UTM scale on the central meridian\n\n    // ---- easting, northing: Karney 2011 Eq 7-14, 29, 35:\n\n    var e = Math.sqrt(f*(2-f)); // eccentricity\n    var n = f / (2 - f);        // 3rd flattening\n    var n2 = n*n, n3 = n*n2, n4 = n*n3, n5 = n*n4, n6 = n*n5; // TODO: compare Horner-form accuracy?\n\n    var cos? = Math.cos(?), sin? = Math.sin(?), tan? = Math.tan(?);\n\n    var ? = Math.tan(?); // ? ? tan?, ?? ? tan??; prime (?) indicates angles on the conformal sphere\n    var ? = Math.sinh(e*Math.atanh(e*?/Math.sqrt(1+?*?)));\n\n    var ?? = ?*Math.sqrt(1+?*?) - ?*Math.sqrt(1+?*?);\n\n    var ?? = Math.atan2(??, cos?);\n    var ?? = Math.asinh(sin? / Math.sqrt(??*?? + cos?*cos?));\n\n    var A = a/(1+n) * (1 + 1/4*n2 + 1/64*n4 + 1/256*n6); // 2?A is the circumference of a meridian\n\n    var ? = [ 0, // note ? is one-based array (6th order Kr?ger expressions)\n        1/2*n - 2/3*n2 + 5/16*n3 + 41/180*n4 - 127/288*n5 + 7891/37800*n6,\n        13/48*n2 - 3/5*n3 + 557/1440*n4 + 281/630*n5 - 1983433/1935360*n6,\n        61/240*n3 - 103/140*n4 + 15061/26880*n5 + 167603/181440*n6,\n        49561/161280*n4 - 179/168*n5 + 6601661/7257600*n6,\n        34729/80640*n5 - 3418889/1995840*n6,\n        212378941/319334400*n6 ];\n\n    var ? = ??;\n    for (var j=1; j<=6; j++) ? += ?[j] * Math.sin(2*j*??) * Math.cosh(2*j*??);\n\n    var ? = ??;\n    for (var j=1; j<=6; j++) ? += ?[j] * Math.cos(2*j*??) * Math.sinh(2*j*??);\n\n    var x = k0 * A * ?;\n    var y = k0 * A * ?;\n\n    // ---- convergence: Karney 2011 Eq 23, 24\n\n    var p? = 1;\n    for (var j=1; j<=6; j++) p? += 2*j*?[j] * Math.cos(2*j*??) * Math.cosh(2*j*??);\n    var q? = 0;\n    for (var j=1; j<=6; j++) q? += 2*j*?[j] * Math.sin(2*j*??) * Math.sinh(2*j*??);\n\n    var ?? = Math.atan(?? / Math.sqrt(1+??*??)*tan?);\n    var ?? = Math.atan2(q?, p?);\n\n    var ? = ?? + ??;\n\n    // ---- scale: Karney 2011 Eq 25\n\n    var sin? = Math.sin(?);\n    var k? = Math.sqrt(1 - e*e*sin?*sin?) * Math.sqrt(1 + ?*?) / Math.sqrt(??*?? + cos?*cos?);\n    var k? = A / a * Math.sqrt(p?*p? + q?*q?);\n\n    var k = k0 * k? * k?;\n\n    // ------------\n\n    // shift x/y to false origins\n    x = x + falseEasting;             // make x relative to false easting\n    if (y < 0) y = y + falseNorthing; // make y in southern hemisphere relative to false northing\n\n    // round to reasonable precision\n    x = Number(x.toFixed(6)); // nm precision\n    y = Number(y.toFixed(6)); // nm precision\n    var convergence = Number(?.toDegrees().toFixed(9));\n    var scale = Number(k.toFixed(12));\n\n    var h = this.lat>=0 ? 'N' : 'S'; // hemisphere\n\n    return new Utm(zone, h, x, y, this.datum, convergence, scale);\n};\n\n\n/**\n * Converts UTM zone/easting/northing coordinate to latitude/longitude\n *\n * @param   {Utm}     utmCoord - UTM coordinate to be converted to latitude/longitude.\n * @returns {LatLon} Latitude/longitude of supplied grid reference.\n *\n * @example\n *   var grid = new Utm(31, 'N', 448251.795, 5411932.678);\n *   var latlong = grid.toLatLonE(); // latlong.toString(): 48?51?29.52?N, 002?17?40.20?E\n */\nUtm.prototype.toLatLonE = function() {\n    var z = this.zone;\n    var h = this.hemisphere;\n    var x = this.easting;\n    var y = this.northing;\n\n    if (isNaN(z) || isNaN(x) || isNaN(y)) throw new Error('Invalid coordinate');\n\n    var falseEasting = 500e3, falseNorthing = 10000e3;\n\n    var a = this.datum.ellipsoid.a, f = this.datum.ellipsoid.f;\n    // WGS 84:  a = 6378137, b = 6356752.314245, f = 1/298.257223563;\n\n    var k0 = 0.9996; // UTM scale on the central meridian\n\n    x = x - falseEasting;               // make x ? relative to central meridian\n    y = h=='S' ? y - falseNorthing : y; // make y ? relative to equator\n\n    // ---- from Karney 2011 Eq 15-22, 36:\n\n    var e = Math.sqrt(f*(2-f)); // eccentricity\n    var n = f / (2 - f);        // 3rd flattening\n    var n2 = n*n, n3 = n*n2, n4 = n*n3, n5 = n*n4, n6 = n*n5;\n\n    var A = a/(1+n) * (1 + 1/4*n2 + 1/64*n4 + 1/256*n6); // 2?A is the circumference of a meridian\n\n    var ? = x / (k0*A);\n    var ? = y / (k0*A);\n\n    var ? = [ 0, // note ? is one-based array (6th order Kr?ger expressions)\n        1/2*n - 2/3*n2 + 37/96*n3 - 1/360*n4 - 81/512*n5 + 96199/604800*n6,\n        1/48*n2 + 1/15*n3 - 437/1440*n4 + 46/105*n5 - 1118711/3870720*n6,\n        17/480*n3 - 37/840*n4 - 209/4480*n5 + 5569/90720*n6,\n        4397/161280*n4 - 11/504*n5 - 830251/7257600*n6,\n        4583/161280*n5 - 108847/3991680*n6,\n        20648693/638668800*n6 ];\n\n    var ?? = ?;\n    for (var j=1; j<=6; j++) ?? -= ?[j] * Math.sin(2*j*?) * Math.cosh(2*j*?);\n\n    var ?? = ?;\n    for (var j=1; j<=6; j++) ?? -= ?[j] * Math.cos(2*j*?) * Math.sinh(2*j*?);\n\n    var sinh?? = Math.sinh(??);\n    var sin?? = Math.sin(??), cos?? = Math.cos(??);\n\n    var ?? = sin?? / Math.sqrt(sinh??*sinh?? + cos??*cos??);\n\n    var ?i = ??;\n    do {\n        var ?i = Math.sinh(e*Math.atanh(e*?i/Math.sqrt(1+?i*?i)));\n        var ?i? = ?i * Math.sqrt(1+?i*?i) - ?i * Math.sqrt(1+?i*?i);\n        var ??i = (?? - ?i?)/Math.sqrt(1+?i?*?i?)\n            * (1 + (1-e*e)*?i*?i) / ((1-e*e)*Math.sqrt(1+?i*?i));\n         ?i += ??i;\n    } while (Math.abs(??i) > 1e-12); // using IEEE 754 ??i -> 0 after 2-3 iterations\n    // note relatively large convergence test as ??i toggles on ?1.12e-16 for eg 31 N 400000 5000000\n    var ? = ?i;\n\n    var ? = Math.atan(?);\n\n    var ? = Math.atan2(sinh??, cos??);\n\n    // ---- convergence: Karney 2011 Eq 26, 27\n\n    var p = 1;\n    for (var j=1; j<=6; j++) p -= 2*j*?[j] * Math.cos(2*j*?) * Math.cosh(2*j*?);\n    var q = 0;\n    for (var j=1; j<=6; j++) q += 2*j*?[j] * Math.sin(2*j*?) * Math.sinh(2*j*?);\n\n    var ?? = Math.atan(Math.tan(??) * Math.tanh(??));\n    var ?? = Math.atan2(q, p);\n\n    var ? = ?? + ??;\n\n    // ---- scale: Karney 2011 Eq 28\n\n    var sin? = Math.sin(?);\n    var k? = Math.sqrt(1 - e*e*sin?*sin?) * Math.sqrt(1 + ?*?) * Math.sqrt(sinh??*sinh?? + cos??*cos??);\n    var k? = A / a / Math.sqrt(p*p + q*q);\n\n    var k = k0 * k? * k?;\n\n    // ------------\n\n    var ?0 = ((z-1)*6 - 180 + 3).toRadians(); // longitude of central meridian\n    ? += ?0; // move ? from zonal to global coordinates\n\n    // round to reasonable precision\n    var lat = Number(?.toDegrees().toFixed(11)); // nm precision (1nm = 10^-11?)\n    var lon = Number(?.toDegrees().toFixed(11)); // (strictly lat rounding should be ??cos?!)\n    var convergence = Number(?.toDegrees().toFixed(9));\n    var scale = Number(k.toFixed(12));\n\n    var latLong = new LatLon(lat, lon, this.datum);\n    // ... and add the convergence and scale into the LatLon object ... wonderful JavaScript!\n    latLong.convergence = convergence;\n    latLong.scale = scale;\n\n    return latLong;\n};\n\n\n/**\n * Parses string representation of UTM coordinate.\n *\n * A UTM coordinate comprises (space-separated)\n *  - zone\n *  - hemisphere\n *  - easting\n *  - northing.\n *\n * @param   {string} utmCoord - UTM coordinate (WGS 84).\n * @param   {Datum}  [datum=WGS84] - Datum coordinate is defined in (default WGS 84).\n * @returns {Utm}\n * @throws  Error Invalid UTM coordinate\n *\n * @example\n *   var utmCoord = Utm.parse('31 N 448251 5411932');\n *   // utmCoord: {zone: 31, hemisphere: 'N', easting: 448251, northing: 5411932 }\n */\nUtm.parse = function(utmCoord, datum) {\n    if (datum === undefined) datum = LatLon.datum.WGS84; // default if not supplied\n\n    // match separate elements (separated by whitespace)\n    utmCoord = utmCoord.trim().match(/\\S+/g);\n\n    if (utmCoord==null || utmCoord.length!=4) throw new Error('Invalid UTM coordinate');\n\n    var zone = utmCoord[0], hemisphere = utmCoord[1], easting = utmCoord[2], northing = utmCoord[3];\n\n    return new Utm(zone, hemisphere, easting, northing, datum);\n};\n\n\n/**\n * Returns a string representation of a UTM coordinate.\n *\n * To distinguish from MGRS grid zone designators, a space is left between the zone and the\n * hemisphere.\n *\n * @param   {number} [digits=0] - Number of digits to appear after the decimal point (3 ? mm).\n * @returns {string} A string representation of the coordinate.\n */\nUtm.prototype.toString = function(digits) {\n    digits = Number(digits||0); // default 0 if not supplied\n\n    var z = this.zone;\n    var h = this.hemisphere;\n    var e = this.easting;\n    var n = this.northing;\n    if (isNaN(z) || !h.match(/[NS]/) || isNaN(e) || isNaN(n)) return '';\n\n    return z+' '+h+' '+e.toFixed(digits)+' '+n.toFixed(digits);\n};\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\n\n/** Polyfill Math.sinh for old browsers / IE */\nif (Math.sinh === undefined) {\n    Math.sinh = function(x) {\n        return (Math.exp(x) - Math.exp(-x)) / 2;\n    };\n}\n\n/** Polyfill Math.cosh for old browsers / IE */\nif (Math.cosh === undefined) {\n    Math.cosh = function(x) {\n        return (Math.exp(x) + Math.exp(-x)) / 2;\n    };\n}\n\n/** Polyfill Math.tanh for old browsers / IE */\nif (Math.tanh === undefined) {\n    Math.tanh = function(x) {\n        return (Math.exp(x) - Math.exp(-x)) / (Math.exp(x) + Math.exp(-x));\n    };\n}\n\n/** Polyfill Math.asinh for old browsers / IE */\nif (Math.asinh === undefined) {\n    Math.asinh = function(x) {\n        return Math.log(x + Math.sqrt(1 + x*x));\n    };\n}\n\n/** Polyfill Math.atanh for old browsers / IE */\nif (Math.atanh === undefined) {\n    Math.atanh = function(x) {\n        return Math.log((1+x) / (1-x)) / 2;\n    };\n}\n\n\n/** Polyfill String.trim for old browsers\n *  (q.v. blog.stevenlevithan.com/archives/faster-trim-javascript) */\nif (String.prototype.trim === undefined) {\n    String.prototype.trim = function() {\n        return String(this).replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n    };\n}\n\n\n/** Extend Number object with method to pad with leading zeros to make it w chars wide\n *  (q.v. stackoverflow.com/questions/2998784 */\nif (Number.prototype.pad === undefined) {\n    Number.prototype.pad = function(w) {\n        var n = this.toString();\n        while (n.length < w) n = '0' + n;\n        return n;\n    };\n}\n\nMgrs.latBands = 'CDEFGHJKLMNPQRSTUVWXX'; // X is repeated for 80-84?N\n\n\n/**\n * 100km grid square column (?e?) letters repeat every third zone\n * @private\n */\nMgrs.e100kLetters = [ 'ABCDEFGH', 'JKLMNPQR', 'STUVWXYZ' ];\n\n\n/**\n * 100km grid square row (?n?) letters repeat every other zone\n * @private\n */\nMgrs.n100kLetters = ['ABCDEFGHJKLMNPQRSTUV', 'FGHJKLMNPQRSTUVABCDE'];\n\n\n/**\n * Creates an Mgrs grid reference object.\n *\n * @classdesc Convert MGRS grid references to/from UTM coordinates.\n *\n * @constructor\n * @param  {number} zone - 6? longitudinal zone (1..60 covering 180?W..180?E).\n * @param  {string} band - 8? latitudinal band (C..X covering 80?S..84?N).\n * @param  {string} e100k - First letter (E) of 100km grid square.\n * @param  {string} n100k - Second letter (N) of 100km grid square.\n * @param  {number} easting - Easting in metres within 100km grid square.\n * @param  {number} northing - Northing in metres within 100km grid square.\n * @param  {LatLon.datum} [datum=WGS84] - Datum UTM coordinate is based on.\n * @throws {Error} Invalid MGRS grid reference\n *\n * @example\n *   var mgrsRef = new Mgrs(31, 'U', 'D', 'Q', 48251, 11932); // 31U DQ 48251 11932\n */\nfunction Mgrs(zone, band, e100k, n100k, easting, northing, datum) {\n    // allow instantiation without 'new'\n    if (!(this instanceof Mgrs)) return new Mgrs(zone, band, e100k, n100k, easting, northing, datum);\n\n    if (datum === undefined) datum = LatLon.datum.WGS84; // default if not supplied\n\n    if (!(1<=zone && zone<=60)) throw new Error('Invalid MGRS grid reference');\n    if (band.length != 1) throw new Error('Invalid MGRS grid reference');\n    if (Mgrs.latBands.indexOf(band) == -1) throw new Error('Invalid MGRS grid reference');\n    if (e100k.length!=1 || n100k.length!=1) throw new Error('Invalid MGRS grid reference');\n\n    this.zone = Number(zone);\n    this.band = band;\n    this.e100k = e100k;\n    this.n100k = n100k;\n    this.easting = Number(easting);\n    this.northing = Number(northing);\n}\n\n\n/**\n * Converts UTM coordinate to MGRS reference.\n *\n * @returns {Mgrs}\n * @throws  {Error} Invalid coordinate\n *\n * @example\n *   var utmCoord = new Utm(31, 'N', 448251, 5411932);\n *   var mgrsRef = utmCoord.toMgrs(); // mgrsRef.toString() = '31U DQ 48251 11932'\n */\nUtm.prototype.toMgrs = function() {\n    if (isNaN(this.zone + this.easting + this.northing)) throw new Error('Invalid UTM coordinate');\n\n    // MGRS zone is same as UTM zone\n    var zone = this.zone;\n\n    // convert UTM to lat/long to get latitude to determine band\n    var latlong = this.toLatLonE();\n    // grid zones are 8? tall, 0?N is 10th band\n    var band = Mgrs.latBands.charAt(Math.floor(latlong.lat/8+10)); // latitude band\n\n    // columns in zone 1 are A-H, zone 2 J-R, zone 3 S-Z, then repeating every 3rd zone\n    var col = Math.floor(this.easting / 100000);\n    var e100k = Mgrs.e100kLetters[(zone-1)%3].charAt(col-1); // TODO: why col-1?\n\n    // rows in even zones are A-V, in odd zones are F-E\n    var row = Math.floor(this.northing / 100000) % 20;\n    var n100k = Mgrs.n100kLetters[(zone-1)%2].charAt(row);\n\n    // truncate easting/northing to within 100km grid square\n    var easting = this.easting % 100000;\n    var northing = this.northing % 100000;\n\n    // round to nm precision\n    easting = Number(easting.toFixed(6));\n    northing = Number(northing.toFixed(6));\n\n    return new Mgrs(zone, band, e100k, n100k, easting, northing);\n};\n\n\n/**\n * Converts MGRS grid reference to UTM coordinate.\n *\n * @returns {Utm}\n *\n * @example\n *   var mgrsRef = Mgrs(31, 'U', 'D', 'Q', 448251, 11932);\n *   var utmCoord = mgrsRef.toUtm(); // utmCoord.toString() = '31 N 448251 5411932'\n */\nMgrs.prototype.toUtm = function() {\n    var zone = this.zone;\n    var band = this.band;\n    var e100k = this.e100k;\n    var n100k = this.n100k;\n    var easting = this.easting;\n    var northing = this.northing;\n\n    var hemisphere = band>='N' ? 'N' : 'S';\n\n    // get easting specified by e100k\n    var col = Mgrs.e100kLetters[(zone-1)%3].indexOf(e100k) + 1; // TODO: why +1?\n    var e100kNum = col * 100000; // e100k in metres\n\n    // get northing specified by n100k\n    var row = Mgrs.n100kLetters[(zone-1)%2].indexOf(n100k);\n    var n100kNum = row * 100000; // n100k in metres\n\n    // get latitude of (bottom of) band\n    var latBand = (Mgrs.latBands.indexOf(band)-10)*8;\n\n    // 100km grid square row letters repeat every 2,000km north; add enough 2,000km blocks to get\n    // into required band\n    var nBand = new LatLon(latBand, 0).toUtm().northing; // northing of bottom of band\n    var n2M = 0; // northing of 2,000km block\n    while (n2M + n100kNum + northing < nBand) n2M += 2000000;\n\n    return new Utm(zone, hemisphere, e100kNum+easting, n2M+n100kNum+northing);\n};\n\n\n/**\n * Parses string representation of MGRS grid reference.\n *\n * An MGRS grid reference comprises (space-separated)\n *  - grid zone designator (GZD)\n *  - 100km grid square letter-pair\n *  - easting\n *  - northing.\n *\n * @param  {string} mgrsGridRef - String representation of MGRS grid reference.\n * @returns {Mgrs} Mgrs grid reference object.\n *\n * @example\n *   var mgrsRef = Mgrs.parse('31U DQ 48251 11932');\n *   var mgrsRef = Mgrs.parse('31UDQ4825111932');\n *   //  mgrsRef: { zone:31, band:'U', e100k:'D', n100k:'Q', easting:48251, northing:11932 }\n */\nMgrs.parse = function(mgrsGridRef) {\n    mgrsGridRef = mgrsGridRef.trim();\n\n    // check for military-style grid reference with no separators\n    if (!mgrsGridRef.match(/\\s/)) {\n        var en = mgrsGridRef.slice(5); // get easting/northing following zone/band/100ksq\n        en = en.slice(0, en.length/2)+' '+en.slice(-en.length/2); // separate easting/northing\n        mgrsGridRef = mgrsGridRef.slice(0, 3)+' '+mgrsGridRef.slice(3, 5)+' '+en; // insert spaces\n    }\n\n    // match separate elements (separated by whitespace)\n    mgrsGridRef = mgrsGridRef.match(/\\S+/g);\n\n    if (mgrsGridRef==null || mgrsGridRef.length!=4) throw new Error('Invalid MGRS grid reference');\n\n    // split gzd into zone/band\n    var gzd = mgrsGridRef[0];\n    var zone = gzd.slice(0, 2);\n    var band = gzd.slice(2, 3);\n\n    // split 100km letter-pair into e/n\n    var en100k = mgrsGridRef[1];\n    var e100k = en100k.slice(0, 1);\n    var n100k = en100k.slice(1, 2);\n\n    var e = mgrsGridRef[2], n = mgrsGridRef[3];\n\n    // standardise to 10-digit refs - ie metres) (but only if < 10-digit refs, to allow decimals)\n    e = e.length>=5 ?  e : (e+'00000').slice(0, 5);\n    n = n.length>=5 ?  n : (n+'00000').slice(0, 5);\n\n    return new Mgrs(zone, band, e100k, n100k, e, n);\n};\n\n\n/**\n * Returns a string representation of an MGRS grid reference.\n *\n * To distinguish from civilian UTM coordinate representations, no space is included within the\n * zone/band grid zone designator.\n *\n * Components are separated by spaces: for a military-style unseparated string, use\n * Mgrs.toString().replace(/ /g, '');\n *\n * @param   {number} [digits=10] - Precision of returned grid reference (eg 4 = km, 10 = m).\n * @returns {string} This grid reference in standard format.\n *\n * @example\n *   var mgrsStr = Mgrs(31, 'U', 'D', 'Q', 48251, 11932).toString(); // mgrsStr: '31U DQ 48251 11932'\n */\nMgrs.prototype.toString = function(digits) {\n    digits = (digits === undefined) ? 10 : Number(digits);\n\n    var zone = this.zone.pad(2); // ensure leading zero\n    var band = this.band;\n\n    var e100k = this.e100k;\n    var n100k = this.n100k;\n\n    // set required precision\n    var easting = Math.floor(this.easting/Math.pow(10, 5-digits/2));\n    var northing = Math.floor(this.northing/Math.pow(10, 5-digits/2));\n\n    // ensure leading zeros\n    easting = easting.pad(digits/2);\n    northing = northing.pad(digits/2);\n\n    return zone+band + ' ' + e100k+n100k + ' '  + easting + ' ' + northing;\n};\n\nvar latitude = LATITUDE();\nvar longitude = LONGITUDE();\n\nvar latlong = new LatLon(latitude, longitude, LatLon.datum.WGS84);\nvar utmCoord = latlong.toUtm();\nvar mgrsRef = utmCoord.toMgrs();\n\nSETRESULT(mgrsRef.toString())",
            "display": {
              "style": "text",
              "currency": null
            },
            "default_values": null,
            "default_previous_value": false
          }
        ]
      },
      {
        "type": "TextField",
        "key": "5cdd",
        "label": "Code",
        "description": null,
        "required": false,
        "disabled": false,
        "hidden": false,
        "data_name": "code",
        "default_value": null,
        "visible_conditions_type": null,
        "visible_conditions": null,
        "required_conditions_type": null,
        "required_conditions": null,
        "numeric": false,
        "pattern": null,
        "pattern_description": null,
        "min_length": null,
        "max_length": null,
        "default_previous_value": false
      },
      {
        "type": "CalculatedField",
        "key": "2b4f",
        "label": "Eval",
        "description": null,
        "required": false,
        "disabled": false,
        "hidden": false,
        "data_name": "eval",
        "default_value": null,
        "visible_conditions_type": null,
        "visible_conditions": null,
        "required_conditions_type": null,
        "required_conditions": [],
        "expression": "eval($code)",
        "display": {
          "style": "text",
          "currency": null
        },
        "default_values": null,
        "default_previous_value": false
      }
    ],
    "created_at": "2016-06-08T15:47:33Z",
    "updated_at": "2016-06-08T16:35:58Z"
  }
}